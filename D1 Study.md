# D1 Study

## 잡다한 것

- **Build.cs** : 개별 모듈의 빌드 방법 정의 (의존성, 포함 경로, 컴파일러 설정 등, 플랫폼별 조건부 설정 가능, 빌드 최적화 옵션 설정 가능)

- **Target.cs** : 프로젝트 전체의 빌드 대상 정의 (게임, 에디터, 서버 등, 빌드 구성에 따른 설정을 관리, 빌드 시 포함할 추가 모듈 지정 가능, 특정 플랫폼을 위한 전용 설정 구성 가능)

- **.uproject** : 언리얼 엔진 프로젝트의 핵심 설정 파일 (모듈 정의, 플러그인 관리 등)

- 해당 에러 뜨는 것 해결법
  
  - 관찰 대상으로 넣어줘야 됨. (Project Settings - Asset Manager)

![](D1%20Study_assets/2025-03-02-14-56-14-image.png)

![](D1%20Study_assets/2025-03-02-14-59-44-image.png)

- LyraHero 컴포넌트를 캐릭터 쪽에 따로 추가해줘야 함을 까먹지 말기!!!! (Lyra 프레임 워크에선)
  
  - 왜 한번에 C++로 만들지 왜 이 부분만 blueprint로 만들게 해놨냐???
    
    - 옛날부터 고전적으로 계승되어 오던 언리얼 엔진 프레임워크 상에 또 다른 컨텐츠 프레임워크를 쌓아 올린 형태이기 때문에 생명주기 이슈가 발생해서 이걸 blueprint로 붙여야지만 모든 애들이 초기화가 끝난 다음에 그 다음 tick에 되므로 (blueprint가 좀 더 느리게 초기화 되므로)

- UPROPERTY(Config)
  
  - 이런 식으로  Config가 써져있으면 Config 파일에서 설정을 하겠다는 뜻임.

- 블루프린트로 만들었으면 (AssetManager에서)

![](D1%20Study_assets/2025-03-02-19-28-24-image.png)

- TSubclassOf
  
  - 특정 클래스 타입을 안전하게 저장하도록 해주는 템플릿 클래스
  
  - 에디터에서 해당 클래스의 자식 클래스만 선택 가능

- CDO
  
  - 클래스당 하나만 존재하는 기본 객체입니다:
    
    - **정의**: 각 `UClass`마다 하나씩 존재하는 기본 객체 인스턴스
    - **주요 역할**:
      1. **템플릿으로서의 역할**: 새 인스턴스 생성 시 기본 속성 값의 템플릿으로 사용
      2. **델타 직렬화의 기준점**: 객체 저장 시 CDO와 다른 값만 저장하여 용량 절약

- StaticClass & 리플렉션 시스템
  
  - 클래스의 메타데이터에 접근할 수 있게 해주는 시스템입니다:
    
    - **StaticClass**: 클래스의 `UClass` 객체를 반환하는 정적 함수
      
      - UClass 객체는 언리얼 엔진의 리플렉션 시스템의 핵심 요소입니다. 각 클래스의 메타데이터를 담고 있는 객체로, 클래스의 구조와 속성에 관한 정보를 런타임에 접근할 수 있게 해줍니다.
    
    - **리플렉션**:
      
      - **정의**: 런타임에 클래스, 함수, 프로퍼티 정보에 접근하고 조작할 수 있는 기능
      - **활성화 매크로**:
        - `UCLASS()`: 클래스 리플렉션 활성화
        - `GENERATED_BODY()`: 리플렉션 코드 생성
        - `UPROPERTY()`: 변수 리플렉션 활성화
        - `UFUNCTION()`: 함수 리플렉션 활성화
    
    - **리플렉션 기능**:
      
      - 속성 값 동적 조회/수정
      - 함수 동적 호출
      - 직렬화/역직렬화 지원
      - 네트워크 복제 지원
      - 에디터 통합

- 언리얼이나 Lyra에서 권장하는 것
  
  - 클래스 참조나 에셋 참조와 같은 설정을 가능한 한 에디터에서 수행
  
  - 그리고 실제로 쌩 C++을 이용하는 경우 잘 없음
    
    - Blueprint 클래스를 파줌

- RPC의 핵심 : 내가 호출을 하지만 상대방이 실행을 한다.

- 인비지블한 메쉬가 애니메이션을 트는 데 그 애니메이션 포즈 그대로를 각 엑터한테도 적용하고 싶을 때 (방어구류 같은 거 따로 붙여놨자너)
  
  - 인비지블한 메쉬만 가능한 건 또 아님.

![](D1%20Study_assets/2025-03-04-11-54-53-image.png)

- (애니메이션) State Alias
  
  - 여러 유사한 상태를 하나의 별칭으로 묶어서 관리 가능
  
  - 여러 상태에서 동일한 전환 로직을 사용할 때 별칭을 통해 중복 코드를 줄일 수 있음

- Blueprint Thread Safe Update Animation (#2)
  
  - 애니메이션 업데이트를 별도의 스레드에서 실행해 메인 게임 스레드의 부하를 줄임 (성능 개선)
  
  - 단 이걸 쓸때는 Thread Safe한 코드만 실행이 가능. (기존처럼 아무꺼나 막 꺼내와서 쓸 수 없음.)

- Animation Blueprint Linking (#3, #4)
  
  - **상위-하위 관계 설정**: 하나의 애니메이션 블루프린트를 다른 블루프린트의 부모로 설정할 수 있습니다.
  - **애니메이션 로직 공유**: 공통된 애니메이션 로직을 부모 블루프린트에 정의하고 여러 자식 블루프린트에서 재사용할 수 있습니다.
  - **변수 및 함수 상속**: 부모 블루프린트의 변수와 함수를 자식 블루프린트에서 접근하고 활용할 수 있습니다.
  - **오버라이드 기능**: 자식 블루프린트에서 부모의 기능을 필요에 따라 오버라이드할 수 있습니다.
  - 클래스에 따라 다 만들려면 복잡해지니깐 이를 이용.
  - 인터페이스를 만들어서 적용.

- 어떤 애니메이션을 몽타주로 만들어야 되고 어떤 애니메이션을 스테이트 머신이나 블랜드 스페이스로 만들어야 할까?
  
  - **몽타주** : 상태와 무관하게 언제든 재생 가능, **슬롯 시스템**으로 부분 애니메이션 가능, 노티파이 이벤트로 타이밍 제어 용이
    
    - 스킬, 특수 공격, 상호작용, 피격 반응, 특수 능력, 중단 가능한 액션 등
  
  - **스테이트 머신**: 기본 상태 관리와 전환 로직에 적합 
    
    - 일상 상태 관련
  
  - **블렌드 스페이스**: 파라미터(속도, 방향 등)에 따라 애니메이션 부드럽게 혼합
    
    - 일상 상태 관련

- **Equipment Slot Type의 개념**(#2):
  
  - 아이템이 장착될 수 있는 특정 위치를 정의 (예: Primary Left Hand, 인벤토리, 창고)
  
  - 이를 통해 아이템의 현재 상태와 위치를 추적
  
  - **아이템 관리를 위한 두 가지 접근법**:
    a) **클라이언트(싱글 플레이) 중심 접근법**:
    
    - 각 위치(인벤토리, 장비창, 창고)마다 별도의 매니저 클래스 생성
    - 아이템을 장착할 때는 인벤토리 매니저에서 장비 매니저로 아이템을 이동
    - 간단하고 직관적이지만 멀티플레이어 확장성에 제한이 있을 수 있음
    
    b) **온라인 게임(특히 MMO) 접근법**:
    
    - 하나의 통합된 아이템 매니저에서 Equipment Slot Type으로 위치 구분
    - 데이터베이스 저장/로드를 고려한 설계
    - 아이템 이동 시 단순히 Slot Type 값만 변경하면 됨
    - 이 방식은 DB 테이블 간 복잡한 이동 로직이 필요 없이 하나의 정수 값만 업데이트하면 됨

- 특정 버튼(input)을 주면 UI창이 열리고 하는 것을 스킬(어빌리티 시스템)로 뺌.
  
  - 장점 
    
    - 특정 상황에서의 규칙 생성이 용이
    
    - 컴포넌트 간 종속성 완화

- GOOD 강의
  
  - item10 - (9도 나쁘지는 않음 최종본을 미리 파악 가능)

- (드래그 관련 #12) 마우스를 가져다 댔을 때 hover widget이 뜨는거랑 드래그 중일 때 아이템이 따라 오고 있는데 이런 거에 대한 처리는 어디서?
  
  - D1ItemDragDrop이라는 것을 캐스팅해서 사용 중인데 이거를 어딘가에서 누군가가 생성을 해 준 적이 있을 것이다. - 그걸 찾아보면 됨.

---

##### 모듈과 플러그인의 차이점

- **구조와 포함 관계**
  - 플러그인은 모듈의 상위 개념으로, 최소 하나 이상의 모듈로 구성됨
  - 플러그인은 여러 모듈을 조합한 완제품 형태
- **구성 요소**
  - 모듈: C++ 코드 중심
  - 플러그인: C++ 코드 + 블루프린트, 머티리얼 등 다양한 에셋 포함 가능
- **개발 흐름**
  - 에픽게임즈는 실험적 기능을 플러그인으로 먼저 테스트
  - 안정성이 검증된 후 엔진의 모듈로 통합
- **활용성**
  - 모듈: 코드 기능 단위
  - 플러그인: 완전한 기능을 제공하는 독립 패키지

##### Game Feature (플러그인 중 하나임)

- **정의**: 게임의 특정 모드나 기능을 독립적으로 관리하는 플러그인 시스템

- **구조적 특징**:
  
  - 공통 코어 시스템은 메인 소스 코드에 유지
  - 모드별 특화 기능은 개별 Game Feature 플러그인으로 분리
  - 각 Game Feature는 독립적으로 활성화/비활성화 가능

- **주요 장점**:
  
  - 복잡한 게임의 기능별 모듈화로 코드 관리 용이
  - 필요한 기능만 로드하여 성능 최적화
  - 팀별 병렬 개발 가능성 증가
  - 런타임에 동적으로 기능 추가/제거 가능

##### 게임 모드 관리 방식

- **기존 방식**
  
  - WorldSettings의 SelectedGameMode를 통해 게임 모드를 지정
  - 게임 모드 전환은 상당히 무거운 작업
  - 다른 게임 모드로 전환 시 많은 시스템이 재초기화되어야 함
  - 맵마다 다른 게임 모드를 사용하려면 맵 로딩이 필요

- **Lyra 기반 신규 방식**
  
  - 하나의 공통 게임 모드를 기반으로 동작
  - Experience 시스템을 통해 게임 모드의 기능을 동적으로 변경
  - Game Feature 플러그인으로 모드별 기능을 모듈화
  - 맵 로딩 없이도 게임 경험을 완전히, 그리고 빠르게 전환 가능
  - 게임 상태를 유지하면서 새로운 기능을 활성화/비활성화 가능

##### Experience Definition - 얘만 Data asset 방식이 아닌 블루프린트

- **게임 모드 설정 통합 관리**
  
  - 게임플레이 모드, 규칙, 설정을 하나의 에셋으로 패키징
  - 기존 방식(WorldSettings의 GameMode 변경)보다 가볍고 유연한 전환 제공

- **모듈식 게임플레이 구성 요소 적용**
  
  - 입력 매핑
  - UI 레이아웃
  - 플레이어 능력(Abilities)
  - 카메라 설정
  - 게임 규칙 설정

- **런타임 전환 지원**
  
  - 맵 변경 없이도 게임 모드/경험을 동적으로 전환 가능
  - 새 맵을 로드할 때 자동으로 관련 경험 적용 가능

- **Game Feature 플러그인 연동**
  
  - 특정 경험에 필요한 Game Feature 플러그인을 자동으로 활성화
  - 불필요한 기능은 비활성화하여 리소스 최적화

- **데이터 중심 설계**
  
  - 코드 수정 없이 데이터만으로 새로운 게임 모드 생성 가능
  - 디자이너가 프로그래머 도움 없이 게임 경험 조정 가능

- **블루프린트 방식을 사용한 이유**
  
  - **Primary Asset ID 시스템 요구사항**
    - Primary Asset 시스템은 CDO를 통해 작동하도록 설계됨
    - `GetPrimaryAssetId()` 함수가 CDO에서 호출되어야 정상 작동
    - 데이터 에셋 방식으로는 이 요구사항을 충족하기 어려움
  - **클래스 계층 구조 활용**
    - 블루프린트는 클래스 상속 구조를 가지며 CDO를 자동 생성
    - "타고 올라가는" 계층 구조를 통해 에셋 시스템이 정보를 추적
    - 단순 데이터 에셋으로는 이런 클래스 상속 기반 기능을 사용할 수 없음

- Experience Definition의 Action Sets와 Actions는 특정 게임 경험(모드)이 활성화될 때 수행할 작업들을 정의

- **Action Sets의 역할**
  
  - 서로 관련된 Actions들을 논리적 그룹으로 묶음
  - 각 Action Set은 특정 상황이나 맥락에 따라 활성화/비활성화 가능
  - 게임 경험의 여러 측면(UI, 입력, 능력치 등)을 모듈식으로 관리

- **Actions의 기능**
  
  - 플레이어 컨트롤러에 컴포넌트 추가
  - 특정 폰(Pawn) 타입 설정
  - UI 레이아웃 적용
  - 입력 매핑 구성
  - 능력(Ability) 부여
  - 카메라 설정 변경

![](D1%20Study_assets/2025-03-02-12-34-30-image.png)

##### SimplePawnData(LyraPawnData)

![](D1%20Study_assets/2025-03-02-12-31-42-image.png)

##### GladiatorCore(GameFeatureData)

![](D1%20Study_assets/2025-03-02-12-38-52-image.png)

- GameFeature 플러그인이 활성화될 때 수행할 작업들을 정의

- **기존** : 레벨이 바뀌거나 모드가 바뀌거나 한다면 일종의 씬 매니저 같은 코드를 만들어서 거기서 초기에 일어나야 되는 모든 행위들을 하드코딩

- **Actions** : 하드 코딩 방식이 아닌 Actions 배열을 통해 필요한 동작을 선언적으로 정의 가능
  
  - **다양한 기능**
    
    - 컴포넌트 추가/제거
    - 입력 매핑 설정
    - 능력치(Ability) 부여
    - UI 요소 추가
    - 게임 기능 확장

- **Asset Manager** : 에셋 관리 통합 (어떠한 에셋들을 로딩해야 되는지)
  
  - Asset Manager와 연동하여 필요한 에셋들의 로딩 우선순위 설정
  - 플러그인에 필요한 에셋들의 로딩 타이밍 제어
  - 메모리 관리 최적화

##### Gameplay Tags

- 기능 크게 2가지

- enum (열거형)처럼 사용하는 존재

- 계층 구조를 만들 수 있음

- C++에서도 사용하기 위해서 Project settings의 태크 추가 가능하지만 C++파일에서 이 태그 목록을 관리해주자!!
  
  - LyraGameplayTags.h, LyraGameplayTags.cpp

- 참고) lyra 입력 처리가 어떻게 되는지 찾아보기
  
  - LyraHeroComponent에서 InitializePlayerInput이라는 함수 참고

##### AssetManager

- 리소스를 관리하는 전역 혹은 싱글톤 방식의 리소스 매니저

- 참고) 커스텀 AssetManager 지정하는 법
  
  - Project Settings > Engine > General Settings > Asset Manager Class에서 커스텀 AssetManager 클래스 지정

![](D1%20Study_assets/2025-03-02-18-32-17-image.png)

- LyraPawnData는 나중에 데이터 파일을 만들어서 에디터 상에서 이것저것 연결해 준 그 파일이랑 연관성이 있는데 그것을 런타임에 로딩해가지고 에셋 매니저가 들고 있음 -> 그게 여기저기서 많이 사용이 될 것이어서 GetDefaultPawnData()라는 getter 함수를 하나 파둠

![](D1%20Study_assets/2025-03-02-18-37-10-image.png)

- **AssetManager 제약**:
  - 모든 데이터 파일을 관리할 수 있는 것은 아님
  - 특정 클래스 계층 구조를 따르는 자산만 관리
- **클래스 계층 구조**:
  1. **DataAsset** (기본 클래스)
     - 에디터에서 데이터 파일을 생성하고 설정할 수 있는 기본 기능 제공
  2. **PrimaryDataAsset** (DataAsset 상속)
     - DataAsset에 추가 기능이 확장된 클래스
     - 핵심 기능: `getPrimaryAssetId()` - 자산에 고유 식별자 부여
     - 이 식별자를 통해 AssetManager가 로딩/언로딩 관리 가능
  3. **LyraPawnData 등** (PrimaryDataAsset 상속)
     - 게임 특화 데이터 자산 클래스들
- **중요 사항**:
  - 자산을 만들었다고 해서 자동으로 관리되는 것이 아님
  - AssetManager의 관찰 대상이 되도록 별도 등록 필요
  - 등록된 자산만 AssetManager가 효율적으로 로딩/언로딩 관리
  - `PrimaryDataAsset`을 상속받은 클래스들만 `getPrimaryAssetId()`를 통해 고유 식별자를 가질 수 있습니다.
  - 이 고유 식별자는 AssetManager에 해당 에셋을 "관찰 대상"으로 등록하는 데 사용됩니다.
- 참고) **FPrimaryAssetId 구조**
  - `FPrimaryAssetId`는 두 부분으로 구성됩니다:
    - `PrimaryAssetType`: 자산의 유형(Type)을 나타내는 이름
    - `PrimaryAssetName`: 특정 자산의 고유 이름(Name)
- **에셋 관리 설정 위치**:
  1. **Project Settings의 AssetManager**
     - 프로젝트 전체에서 공통으로 사용되는 에셋들을 관리
     - 기본적인 에셋 유형 및 스캔 경로 설정
     - 모든 게임 모듈에서 접근 가능한 에셋 등록
  2. **GameFeatureData의 AssetManager**
     - 특정 플러그인이나 게임 피처에 속한 에셋 관리
     - 플러그인이 활성화될 때만 로드되는 에셋 등록
     - 모듈화된 기능에 대한 독립적인 에셋 관리

##### Cosmetic

- **컴포넌트 기반 설계**
  - 캐릭터의 외형을 독립적인 컴포넌트(헤드, 바디, 팔, 다리 등)로 분리
  - 각 컴포넌트는 개별적으로 교체 및 커스터마이징 가능
  - 모듈식 접근 방식으로 높은 조합 가능성 제공
- **데이터 주도 아키텍처**
  - CharacterData와 같은 데이터 에셋을 통해 가능한 외형 옵션 정의
  - 런타임에 필요한 에셋만 로드하여 메모리 효율성 향상
  - 스킨, 아머, 액세서리 등의 매핑 테이블 관리
- **동적 에셋 관리**
  - 필요에 따라 스켈레탈 메시, 머티리얼, 텍스처 로드 및 언로드
  - 소프트 레퍼런스(TSoftObjectPtr) 활용으로 메모리 사용 최적화
    - `TSoftObjectPtr`은 일반 포인터(`TObjectPtr` 또는 일반 참조)와 달리, 해당 객체를 바로 메모리에 로드하지 않고 객체의 경로만 저장
    - 객체가 실제로 필요할 때까지 메모리에 로드되지 않음
  - 에셋 매니저를 통한 중앙 집중식 리소스 관리
- **커스터마이징 범위**
  - 시각적 요소: 메시, 텍스처, 머티리얼, 컬러
  - 애니메이션: 캐릭터별 고유 애니메이션, 제스처, 이모트
  - 이펙트: 특수 효과, 파티클, 사운드 효과

##### 아이템 설계

- 아이템 구현은 프로젝트마다 다 다를 수 밖에 없음. (형태가 다양)

##### Lyra 인벤토리 시스템 구조 분석(#1)

- 개요

언리얼 엔진 5의 Lyra 샘플 프로젝트에서 사용하는 인벤토리 시스템은 모듈식 설계를 통해 다양한 게임 장르에 적용 가능한 유연한 구조를 가지고 있습니다. 이 문서는 Lyra의 인벤토리 시스템 핵심 컴포넌트들의 역할과 관계를 설명합니다.

- 핵심 컴포넌트
1. LyraInventoryManagerComponent
   
   - **역할**: 모든 아이템들을 통합해서 관리하는 중앙 매니저 컴포넌트
   
   - **위치**: 일반적으로 PlayerState 또는 Pawn에 부착
   
   - **주요 기능**:
     
     - 아이템 인스턴스의 컬렉션 관리
     - 아이템 추가, 제거, 업데이트 처리
     - 인벤토리 변경 이벤트 발생 및 처리
     - 아이템 쿼리 및 필터링 기능 제공

2. LyraInventoryItemDefinition
   
   - **역할**: 아이템의 기본 데이터를 정의하는 에셋(데이터 시트의 구조)
   
   - **특성**:
     
     - 불변(Immutable) 데이터 - 모든 같은 유형의 아이템이 공유하는 속성 정의
     - Fragment 기반 모듈식 설계
   
   - **주요 용도**:
     
     - 게임에 존재하는 모든 종류의 아이템 타입 정의
     
     - 에디터에서 디자이너가 수정 가능한 데이터 제공

3. LyraInventoryItemInstance
   
   - **역할**: 게임 내에서 실제로 존재하는 아이템의 인스턴스
   
   - **특성**:
     
     - 런타임에만 존재하는 메모리 객체 (액터가 아님)
     - Definition과 연결되어 있으며, 해당 Definition의 속성들을 상속
     - 플레이어별 상태 정보 저장 (수량, 장착 상태, 강화 레벨 등)
   
   - **관리**:
     
     - LyraInventoryManagerComponent에 의해 관리됨
     - 직렬화/역직렬화를 통해 저장/로드 가능
- Fragment 패턴
  
  - 개념
    
    - Fragment는 컴포넌트 패턴과 유사한 모듈식 설계 방식
    
    - 각 Fragment는 아이템에 특정 기능이나 속성을 추가
    
    - 하나의 아이템 Definition은 여러 Fragment를 포함할 수 있음
    
    - 주요 Fragment 예시
      
      1. **InventoryFragment_EquippableItem**
         
         - 아이템을 장착 가능하게 만드는 Fragment
         - 장착 슬롯, 장착 효과 등의 정보 포함
      
      2. **InventoryFragment_PickupIcon**
         
         - 월드에 떨어진 아이템의 시각적 표현을 정의
         - 메시, 텍스처, 이펙트 등 포함
      
      3. **InventoryFragment_QuickBarIcon**
         
         - UI에서의 아이템 표현 정의
         - 아이콘, 색상, 레이아웃 정보 등 포함
      
      4. **InventoryFragment_SetStats**
         
         - 아이템이 캐릭터에게 제공하는 스탯 수정 정보
         - 데미지, 방어력, 이동 속도 등의 스탯 보너스 정의

- 작동 방식
  
  1. **아이템 생성 흐름**:
     
     - 디자이너가 LyraInventoryItemDefinition 에셋 생성 및 구성
     - 게임 중 특정 이벤트(픽업, 보상 등)에 의해 아이템 인스턴스 생성 필요
     - LyraInventoryManagerComponent가 Definition을 바탕으로 Instance 생성
     - 생성된 Instance는 Manager에 등록되고 관리됨
  
  2. **아이템 사용 흐름**:
     
     - 플레이어가 UI 또는 단축키를 통해 아이템 사용 시도
     - 요청이 LyraInventoryManagerComponent로 전달
     - Manager는 해당 아이템의 Instance를 찾고 사용 가능 여부 확인
     - Fragment 정보에 따라 적절한 효과나 동작 실행

- 장점 및 확장성
  
  1. **모듈식 설계**:
  - Fragment를 추가하는 방식으로 새로운 기능 확장 가능
  
  - 기존 시스템 수정 없이 새로운 아이템 유형 추가 가능
  2. **데이터 중심 설계**:
     
     - 프로그래머 의존도를 낮추고 디자이너가 직접 아이템 생성/수정 가능
     - 코드 변경 없이 게임 콘텐츠 확장 가능
  
  3. **메모리 효율성**:
     
     - Definition/Instance 분리로 중복 데이터 최소화
     - 필요한 아이템만 인스턴스화하여 메모리 관리 효율적
  
  4. **네트워크 최적화**:
     
     - 불변 데이터(Definition)는 클라이언트와 서버가 공유
     - 가변 데이터(Instance)만 네트워크로 동기화하여 대역폭 절약

- 다만, 모든 것을 Fragment로 관리하기엔 무리가 있음
  
  - 블루프린트 파일 자체가 모든 데이터를 들고 있는 방식이 될텐데...
  
  - 밸런스 관련된 데이터는 나중에 기획자가 관리하기 편하게 하려면 그 데이터만 나중에 따로 엑셀로 뽑아서 따로 관리한다거나 하는게 더 나을 수도 있음
